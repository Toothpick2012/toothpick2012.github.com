<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>IOS类库 | Toothpick</title>
  <meta name="author" content="toothpickv">
  
  
  
  <meta property="og:site_name" content="Toothpick"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta property="og:image" content="undefined"/>
  
   <link rel="apple-touch-icon" href="/icon.png" />
   <link rel="shortcut icon" href="/favicon.png" >
   <link rel="alternate" href="http://xxx.xx/atom.xml" title="Toothpick" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
</head>


<body>
  <div id="content" class="inner">
    <aside id="sidebar" class="alignleft">
      <div class="navigationBar">
        <a href="/">Toothpick</a>
      </div>
    	
  <nav class="widget" id="menu">
	<ul>
    
      <li class="cell"><a class="next" href="/">Home</a><li>
    
      <li class="cell"><a class="next" href="/archives/">Archives</a><li>
    
      <li class="cell"><a class="next" href="/about/">About</a><li>
    
      <li class="cell"><a class="next" href="/atom.xml">Subscribe</a><li>
    
    </ul>
</nav>

  <div class="widget weibo">
<iframe width="100%" height="100" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=110&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=0&isWeibo=0&isFans=0&uid=null&verifier=78e1ee4d&colors=ffffff,ffffff,999,000,ecfbfd&dpc=1"></iframe>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/CSS/">CSS</a><small>1</small></li>
  
    <li><a href="/categories/IOS/">IOS</a><small>8</small></li>
  
    <li><a href="/categories/IOS类库/">IOS类库</a><small>2</small></li>
  
    <li><a href="/categories/PHP/">PHP</a><small>1</small></li>
  
    <li><a href="/categories/coretext/">coretext</a><small>4</small></li>
  
    <li><a href="/categories/mac/">mac</a><small>2</small></li>
  
    <li><a href="/categories/插件/">插件</a><small>1</small></li>
  
    <li><a href="/categories/音乐/">音乐</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/Ad Hoc/" style="font-size: 12.50px;">Ad Hoc</a><a href="/tags/AppStore/" style="font-size: 12.50px;">AppStore</a><a href="/tags/CSS/" style="font-size: 10.00px;">CSS</a><a href="/tags/JDK/" style="font-size: 10.00px;">JDK</a><a href="/tags/Objective-C/" style="font-size: 17.50px;">Objective-C</a><a href="/tags/SASS/" style="font-size: 10.00px;">SASS</a><a href="/tags/SDWebImage/" style="font-size: 10.00px;">SDWebImage</a><a href="/tags/UIApplicationDelegate/" style="font-size: 10.00px;">UIApplicationDelegate</a><a href="/tags/UIImage/" style="font-size: 10.00px;">UIImage</a><a href="/tags/bug/" style="font-size: 10.00px;">bug</a><a href="/tags/ios/" style="font-size: 20.00px;">ios</a><a href="/tags/itunes/" style="font-size: 12.50px;">itunes</a><a href="/tags/java/" style="font-size: 10.00px;">java</a><a href="/tags/mac/" style="font-size: 10.00px;">mac</a><a href="/tags/occurred uploading/" style="font-size: 10.00px;">occurred uploading</a><a href="/tags/uitableview/" style="font-size: 10.00px;">uitableview</a><a href="/tags/优化/" style="font-size: 15.00px;">优化</a><a href="/tags/保存数据/" style="font-size: 10.00px;">保存数据</a><a href="/tags/后台/" style="font-size: 10.00px;">后台</a><a href="/tags/开发者/" style="font-size: 10.00px;">开发者</a><a href="/tags/类库/" style="font-size: 12.50px;">类库</a><a href="/tags/苹果/" style="font-size: 10.00px;">苹果</a><a href="/tags/账号/" style="font-size: 10.00px;">账号</a><a href="/tags/闪退/" style="font-size: 12.50px;">闪退</a><a href="/tags/高效/" style="font-size: 15.00px;">高效</a>
  </div>
</div>


    	<footer id="footer" class="inner"><div class="copyright">
  
  &copy; 2014 toothpickv
  
</div>



</footer>
    </aside>
    
    
    <div id="hidden-navigationBar" class="navigationBar">
      <a href="/">Toothpick</a>
    </div>
    <div id="main-col" class="alignright">
    <div id="wrapper">
      
<h2 class="archive-title category">IOS类库</h2>


  
    
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2012/12/10/sdwebimage-笔记（转）/">SDWebImage 笔记（转）</a></h1>
  

      <time datetime="2012-12-09T18:39:19.000Z"><a href="/2012/12/10/sdwebimage-笔记（转）/">Dec 10 2012</a></time>
      
  </header>
    <div class="entry">
      
        <p>SDWebImage托管在github上。<a href="https://github.com/rs/SDWebImage" target="_blank">https://github.com/rs/SDWebImage</a>
这个类库提供一个UIImageView类别以支持加载来自网络的远程图片。具有缓存管理、异步下载、同一个URL下载次数控制和优化等特征。
使用示范的代码：
UITableView使用UIImageView+WebCache类（基本应用，UIImageView的一个category）
前提#import导入UIImageView+WebCache.h文件，然后在tableview的cellForRowAtIndexPath：方法下： </p>
<p>[html lang=&quot;Objective-C&quot;] </p>
<ul>
<li>(UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath <em>)indexPath {
   static NSString </em>MyIdentifier = @&quot;MyIdentifier&quot;;
   UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:MyIdentifier];
  if (cell == nil) {<pre><code>   cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:MyIdentifier] autorelease];
</code></pre>   }
// Here we use the new provided setImageWithURL: method to load the web image
  [cell.imageView setImageWithURL:[NSURL URLWithString:@&quot;<a href="http://www.domain.com/path/to/image.jpg" target="_blank">http://www.domain.com/path/to/image.jpg</a>&quot;] placeholderImage:[UIImage imageNamed:@&quot;placeholder.png&quot;]];
  cell.textLabel.text = @&quot;My Text&quot;;
  return cell;
}
[/html]</li>
</ul>
<p>基本代码：[imageView setImageWithURL:[NSURL URLWithString:@&quot;<a href="http://www.domain.com/path/image.jpg" target="_blank">http://www.domain.com/path/image.jpg</a>&quot;]];
使用SDWebImageManager类：可以进行一些异步加载的工作。
[html lang=&quot;Objective-C&quot;]
SDWebImageManager <em>manager = [SDWebImageManager sharedManager];
UIImage </em>cachedImage = [manager imageWithURL:url]; // 将需要缓存的图片加载进来
if (cachedImage) {
      // 如果Cache命中，则直接利用缓存的图片进行有关操作
      // Use the cached image immediatly
} else {
      // 如果Cache没有命中，则去下载指定网络位置的图片，并且给出一个委托方法
      // Start an async download
     [manager downloadWithURL:url delegate:self];
}
[/html]
当然你的类要实现SDWebImageManagerDelegate协议，并且要实现协议的webImageManager:didFinishWithImage:方法。
// 当下载完成后，调用回调方法，使下载的图片显示
[html lang=&quot;Objective-C&quot;]</p>
<ul>
<li>(void)webImageManager:(SDWebImageManager <em>)imageManager didFinishWithImage:(UIImage </em>)image {
  // Do something with the downloaded image
}
[/html]
独立的异步图像下载
可能会单独用到异步图片下载，则一定要用downloaderWithURL:delegate:来建立一个SDWebImageDownloader实例。
downloader = [SDWebImageDownloader downloaderWithURL:url delegate:self];
这样SDWebImageDownloaderDelegate协议的方法imageDownloader:didFinishWithImage:被调用时下载会立即开始并完成。</li>
</ul>
<p>独立的异步图像缓存
SDImageCache类提供一个创建空缓存的实例，并用方法imageForKey:来寻找当前缓存。
[html lang=&quot;Objective-C&quot;]
UIImage *myCachedImage = [[SDImageCache sharedImageCache] imageFromKey:myCacheKey];
[/html]</p>
<p>存储一个图像到缓存是使用方法storeImage: forKey:
[[SDImageCache sharedImageCache] storeImage:myImage forKey:myCacheKey];
默认情况下，图像将被存储在内存缓存和磁盘缓存中。如果仅仅是想内存缓存中，要使用storeImage:forKey:toDisk:方法的第三个参数带一负值
来替代。</p>
<p>SDWebImage 支持异步的图片下载+缓存，提供了 UIImageView+WebCacha 的 category，方便使用。纪录一下 SDWebImage 加载图片的流程。
入口 setImageWithURL:placeholderImage:options: 会先把 placeholderImage 显示，然后 SDWebImageManager 根据 URL 开始处理图片。
进入 SDWebImageManager-downloadWithURL:delegate:options:userInfo:，交给 SDImageCache 从缓存查找图片是否已经下载 queryDiskCacheForKey:delegate:userInfo:.
先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存，SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo: 到 SDWebImageManager。
SDWebImageManagerDelegate 回调 webImageManager:didFinishWithImage: 到 UIImageView+WebCache 等前端展示图片。
如果内存缓存中没有，生成 NSInvocationOperation 添加到队列开始从硬盘查找图片是否已经缓存。
根据 URLKey 在硬盘缓存目录下尝试读取图片文件。这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。
如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo:。进而回调展示图片。
如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片，回调 imageCache:didNotFindImageForKey:userInfo:。
共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。
图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。
connection:didReceiveData: 中利用 ImageIO 做了按图片下载进度加载效果。
connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder 做图片解码处理。
图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。
在主线程 notifyDelegateOnMainThreadWithInfo: 宣告解码完成，imageDecoder:didFinishDecodingImage:userInfo: 回调给 SDWebImageDownloader。
imageDownloader:didFinishWithImage: 回调给 SDWebImageManager 告知图片下载完成。
通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。
将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程。
SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片。
SDWI 也提供了 UIButton+WebCache 和 MKAnnotationView+WebCache，方便使用。
SDWebImagePrefetcher 可以预先下载图片，方便后续使用。</p>
<p>SDWebImage库的作用：
通过对UIImageView的类别扩展来实现异步加载替换图片的工作。
主要用到的对象：
1、UIImageView (WebCache)类别，入口封装，实现读取图片完成后的回调
2、SDWebImageManager，对图片进行管理的中转站，记录那些图片正在读取。
向下层读取Cache（调用SDImageCache），或者向网络读取对象（调用SDWebImageDownloader） 。
实现SDImageCache和SDWebImageDownloader的回调。
3、SDImageCache，根据URL的MD5摘要对图片进行存储和读取（实现存在内存中或者存在硬盘上两种实现）
实现图片和内存清理工作。
4、SDWebImageDownloader，根据URL向网络读取数据（实现部分读取和全部读取后再通知回调两种方式）
其他类：
SDWebImageDecoder，异步对图像进行了一次解压⋯⋯
目前不明白为什么要做这么道工序。（现在清楚了，功能解释见下文）
有趣的点：
1、SDImageCache是怎么做数据管理的?
SDImageCache分两个部分，一个是内存层面的，一个是硬盘层面的。
内存层面的相当是个缓存器，以Key-Value的形式存储图片。当内存不够的时候会清除所有缓存图片。
用搜索文件系统的方式做管理，文件替换方式是以时间为单位，剔除时间大于一周的图片文件。
当SDWebImageManager向SDImageCache要资源时，先搜索内存层面的数据，如果有直接返回，没有的话去访问磁盘，将图片从磁盘读取出来，然后做Decoder，将图片对象放到内存层面做备份，再返回调用层。
2、为啥必须做Decoder?
通过这个博客：[crayon url=&quot;<a href="http://www.cocoanetics.com/2011/10/avoiding-image-decompression-sickness&quot;]http://www.cocoanetics.com/2011/10/avoiding-image-decompression-sickness/[/crayon" target="_blank">http://www.cocoanetics.com/2011/10/avoiding-image-decompression-sickness&quot;]http://www.cocoanetics.com/2011/10/avoiding-image-decompression-sickness/[/crayon</a>]
现在明白了，由于UIImage的imageWithData函数是每次画图的时候才将Data解压成ARGB的图像，
所以在每次画图的时候，会有一个解压操作，这样效率很低，但是只有瞬时的内存需求。
为了提高效率通过SDWebImageDecoder将包装在Data下的资源解压，然后画在另外一张图片上，这样这张新图片就不再需要重复解压了。
这种做法是典型的空间换时间的做法。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="null"><strong>null</strong></a> - Dec 10 2012</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://yoursite.com"><strong>Toothpick</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2012/12/03/hello-world/">iOS高效开发必备的10款Objective-C类库(转)</a></h1>
  

      <time datetime="2012-12-02T23:11:23.000Z"><a href="/2012/12/03/hello-world/">Dec 3 2012</a></time>
      
  </header>
    <div class="entry">
      
        <p>因为iOS SDK相对比较底层，所以开发者就得受累多做一些体力活。不过幸运的是，有很多第三方的类库可以用来简化很多不必要的工作.经过作者团队的慎重讨论，他们评选出了10款能够极大提高iOS开发效率的类库，根据原文作者的评价来看，基本上有了这10款工具，做iOS开发就真的跟泡Cocoa一样了。</p>
<p><a href="http://github.com/jdg/MBProgressHUD" target="_blank"><strong>MBProgressHUD</strong></a><strong>——进展指示符库</strong></p>
<p>苹果的应用程序一般都会用一种优雅的，半透明的进度显示效果，不过这个API是不公开的，因此你要是用了，很可能被清除出AppStore。而MBProgressHUD提供了一个替代方案，而且在用户角度上，实现的效果根本看不出和官方程序有什么差别。同时还提供了其他附加功能，比如虚拟进展指示符，以及完成提示信息。整合到项目里也很容易，这里不细谈了。</p>
<p><a href="http://allseeing-i.com/ASIHTTPRequest/" target="_blank"><strong>ASIHttpRequest</strong></a><strong>——HTTP Network库</strong></p>
<p>iPhone当然也有自己的HTTP Network API，那为什么要用ASIHttpRequest呢？因为官方的API简直跟话痨似的，太罗嗦了！ASIHttpRequest库极大的简化了网络通信，提供更先进的工具，什么文件上传工具，重定向处理工具、验证工具、等等。只要你手头的东西跟HTTP有关，用这个绝对能让你感觉道生活有美好！先看一段代码就体会到了。 </p>
<pre style="padding:0px;list-style:none;width:613.796875px;overflow:hidden;background-color:#f7f7f7;color:#333333;font-size:14px;line-height:24px;margin-top:0px;">

1.  (<span class="keyword">void</span>) loadAppDevMag
2.  {
3.  NSURL *url = [NSURL URLWithString:@<span class="string">"http://www.appdevmag.com"</span>];
4.  ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url];
5.  [request setDelegate:self];
6.  [request startAsynchronous];
7.  }
8.  <span class="span4br"></span>
9.  - (<span class="keyword">void</span>)requestFinished:(ASIHTTPRequest *)request
10.  {
11.  <span class="comment" style="color:#008200;">// Use when fetching text data</span>
12.  NSString *responseString = [request responseString];
13.  }</pre>

<p><a href="http://stig.github.com/json-framework/" target="_blank"><strong>JSON Framework</strong></a><strong>——JSON支持</strong></p>
<p>如果你做的应用和网站服务器有交互，那就得用到JSON了。但事实上，iOS平台的原生类库根本就不支持JSON，这就略犀利了吧？不过JSON框架满足了你的所有需求，包括一个解析器将JSON字符串解析成对象；以及一个生成器从对象生成字符串。这个库根本就是太流行了，JSON提过很多次了，具体特点就不多讲了，所谓“一段代码胜千言”，下面用一段代码演示一下吧。</p>
<pre style="padding:0px;list-style:none;width:613.796875px;overflow:hidden;background-color:#f7f7f7;color:#333333;font-size:14px;line-height:24px;margin-top:0px;">

1.  <span class="comment" style="color:#008200;">// JSON string -> NSDictionary</span>
2.  <span class="span4br"></span>
3.  NSString *jsonString = @<span class="string">"{\"foo\": \"bar\"}"</span>;
4.  <span class="span4br"></span>
5.  NSDictionary *dictionary = [jsonString JSONValue];
6.  <span class="span4br"></span>
7.  NSLog(@<span class="string">"Dictionary value for \"foo\" is \"%@\""</span>, [dictionary objectForKey:@<span class="string">"foo"</span>]);
8.  <span class="span4br"></span>
9.  <span class="comment" style="color:#008200;">// NSDictionary -> JSON string</span>
10.  <span class="span4br"></span>
11.  NSString *newJsonString = [dictionary JSONRepresentation];</pre>

<p><a href="http://www.flurry.com/product/analytics/index.html" target="_blank"><strong>Flurry</strong></a><strong>——详尽的使用统计</strong></p>
<p>通过Furry你可以得到应用的用户人数，用户活跃度，用户来源等统计信息。但是他最厉害的地方是，你可以追踪应用本身的事件和错误记录，所有这些数据都会在一个类似Google Analytics的界面上显示，这样就很容易掌握用户的行为和出现的问题。当然，这个星球上很多统计工具，但是这款是作者个人比较推崇的解决方案。</p>
<p><img src="http://articles.csdn.net/uploads/allimg/110317/102_110317162414_1_lit.JPG" alt="ios Libraries development"></p>
<p><a href="http://regexkit.sourceforge.net/RegexKitLite/" target="_blank"><strong>RegexKitLite</strong></a><strong>——正则表达式支持</strong></p>
<p>正则表达式大家都知道。但是iPhone SDK居然当他不存在？这怎么能忍啊！果断用RegexKitLite。虽然叫的是Lite，但是功能很full。示例代码。 </p>
<pre style="padding:0px;list-style:none;width:613.796875px;overflow:hidden;background-color:#f7f7f7;color:#333333;font-size:14px;line-height:24px;margin-top:0px;">

1.  <span class="comment" style="color:#008200;">// finds phone number in format nnn-nnn-nnnn</span>
2.  NSString *regEx = @<span class="string">"[0-9]{3}-[0-9]{3}-[0-9]{4}"</span>;
3.  <span class="keyword">for</span>(NSString *match in [textView.text componentsMatchedByRegex:regEx]) {
4.  NSLog(@<span class="string">"Phone number is %@"</span>, match);
5.  }</pre>

<p><a href="http://github.com/facebook/facebook-ios-sdk" target="_blank"><strong>Facebook iOS SDK</strong></a><strong>——Facebook API类库</strong></p>
<p>大体来讲就是iPhone上的Facebook login，完全支持Facebook Graph API和the older REST api。如果你的应用跟Facebook有关，相信我，用这个吧。</p>
<p><img src="http://articles.csdn.net/uploads/allimg/110317/102_110317162548_1.png" alt=""></p>
<p><a href="http://github.com/rs/SDWebImage" target="_blank"><strong>SDWebImage</strong></a><strong>——简化网络图片处理</strong></p>
<p>用SDWebImage调用网站上的图片，跟本地调用内置在应用包里的图片一样简单。操作也很简单，举例说明</p>
<pre style="padding:0px;list-style:none;width:613.796875px;overflow:hidden;background-color:#f7f7f7;color:#333333;font-size:14px;line-height:24px;margin-top:0px;">

1.  [imageView setImageWithURL:[NSURL URLWithString:@"http://examp</pre>

<p>类似的功能在Three20里也有，这个过会儿再说。相比而言，SDWebImage主要是提供一个小而精的简捷方便的解决方案</p>
<p><a href="http://code.google.com/p/gdata-objectivec-client/" target="_blank"><strong>GData client</strong></a><strong>——iPhone上所有Google相关服务的类库</strong></p>
<p>名字就说明一切了。跟Google相关的，值得一提的是，这个项目很开放。有很多示例程序供下载。</p>
<p><a href="http://code.google.com/p/core-plot/" target="_blank"><strong>CorePlot</strong></a><strong>——2D图形绘图仪</strong></p>
<p><img src="http://articles.csdn.net/uploads/allimg/110317/102_110317162803_1_lit.jpg" alt=""></p>
<p>CorePlot有很多解决方案将你的数据可视。，同时也会提供各种迷人的图形效果，比如棒状图、饼状图、线状图等等，在他们网站上也提供了大量的范例图形，很多股票价格应用，游戏分数，个人财务管理都在用。</p>
<p><a href="http://github.com/facebook/three20" target="_blank"><strong>Three20</strong></a><strong>——通用iOS库</strong></p>
<p>Three20类库是Facebook自己做的，大而全是他最大的特色。把他整合到已有的项目中可能得费点周折，不过如果一开始你就用上了Three20，尤其是牵扯到很多web相关的项目的时候，你就能深刻体会到神马叫给力了。</p>
<p><span class="span4br"></span></p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="null"><strong>null</strong></a> - Dec 3 2012</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://yoursite.com"><strong>Toothpick</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  

  <nav id="pagination">
  
  
</nav>
</div>
    </div>
    <div class="tabbar" onload="divideTabBar()">
	
      <div class="tabbaritem"><a class="next" href="/">Home</a></div>
    
      <div class="tabbaritem"><a class="next" href="/archives/">Archives</a></div>
    
      <div class="tabbaritem"><a class="next" href="/about/">About</a></div>
    
      <div class="tabbaritem"><a class="next" href="/atom.xml">Subscribe</a></div>
    
</div>


  </div>
</body>
</html>